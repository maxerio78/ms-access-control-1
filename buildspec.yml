version: 0.2

env:
  variables:
    AWS_REGION: "ap-southeast-1"
    ACCOUNT_ID: "432637347995"
    CLUSTER_NAME: "Sun-Series-Travel-Prod"
    K8S_NAMESPACE: "default"

    # ECR repo/ชื่อแอป
    ECR_REPO: "ms-access-control-1"
    APP_NAME: "ms-access-control-1"

    # แท็กภาพ: ใช้ commit SHA ของ CodeBuild ถ้ามี; ไม่มีก็ fallback เป็น latest
    IMAGE_TAG: "latest"

    # ภาพฐานที่จะดึงมา re-tag เป็นของเรา (ใช้ Public ECR แทน Docker Hub)
    BASE_IMAGE: "public.ecr.aws/docker/library/nginx:alpine"

phases:
  install:
    runtime-versions:
      java: corretto17
    commands:
      - "set -euo pipefail"
      - "aws --version"
      - 'echo "Installing kubectl..."'
      - 'K8S_VER=$(aws eks describe-cluster --name "$CLUSTER_NAME" --region "$AWS_REGION" --query "cluster.version" --output text)'
      - 'echo "Detected cluster.version: ${K8S_VER}"'
      - 'curl -fsSL -o /usr/local/bin/kubectl "https://dl.k8s.io/release/v${K8S_VER}.0/bin/linux/amd64/kubectl"'
      - 'chmod +x /usr/local/bin/kubectl'
      - 'kubectl version --client --output=yaml || (echo "kubectl not working"; exit 1)'

  pre_build:
    commands:
      - 'echo "Resolve tag & login ECR..."'
      - 'RESOLVED_TAG="${CODEBUILD_RESOLVED_SOURCE_VERSION:-${IMAGE_TAG}}"'
      - 'echo "RESOLVED_TAG=${RESOLVED_TAG}"'
      - 'ECR_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${RESOLVED_TAG}"'
      - 'echo "ECR_URI=${ECR_URI}"'

      - 'aws ecr describe-repositories --repository-names "$ECR_REPO" --region "$AWS_REGION" || aws ecr create-repository --repository-name "$ECR_REPO" --region "$AWS_REGION"'
      - 'aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"'

      - 'echo "Pull base image & push to ECR..."'
      - 'docker pull "${BASE_IMAGE}"'
      - 'docker tag "${BASE_IMAGE}" "${ECR_URI}"'
      - 'docker push "${ECR_URI}"'

  build:
    commands:
      - 'echo "No build step needed in smoke mode."'

  post_build:
    commands:
      - 'echo "Updating kubeconfig & deploying..."'
      - 'aws eks update-kubeconfig --name "$CLUSTER_NAME" --region "$AWS_REGION"'

      - 'echo "Generate manifest using ECR image..."'
      - |
        cat > /tmp/smoke.yaml <<EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: ${APP_NAME}-smoke
          labels: { app: ${APP_NAME}-smoke }
        spec:
          replicas: 2
          selector: { matchLabels: { app: ${APP_NAME}-smoke } }
          template:
            metadata: { labels: { app: ${APP_NAME}-smoke } }
            spec:
              containers:
                - name: nginx
                  image: ${ECR_URI}
                  ports: [{ containerPort: 80 }]
                  readinessProbe:
                    httpGet: { path: /, port: 80 }
                    initialDelaySeconds: 5
                    periodSeconds: 5
                  livenessProbe:
                    httpGet: { path: /, port: 80 }
                    initialDelaySeconds: 15
                    periodSeconds: 10
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: ${APP_NAME}-smoke
          labels: { app: ${APP_NAME}-smoke }
          annotations:
            service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
            service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
            service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: "ip"
        spec:
          type: LoadBalancer
          selector: { app: ${APP_NAME}-smoke }
          ports:
            - port: 80
              targetPort: 80
              protocol: TCP
        EOF

      - 'kubectl -n "$K8S_NAMESPACE" apply -f /tmp/smoke.yaml'
      - 'kubectl -n "$K8S_NAMESPACE" rollout status deploy/${APP_NAME}-smoke'
      - 'kubectl -n "$K8S_NAMESPACE" get svc ${APP_NAME}-smoke -o wide'
      - 'echo "Smoke deploy with ECR image completed."'

artifacts:
  files:
    - "**/*"
